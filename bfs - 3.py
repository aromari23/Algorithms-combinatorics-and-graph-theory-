def bfs(start, graph, distance):
    # множество для хранения посещённых вершин, чтобы избежать циклов
    visited = set()
    # очередь для обработки вершин, начинаем с стартовой вершины
    queue = [start]

    # пока очередь не пуста (есть вершины для обработки)
    while queue:
        # извлекаем текущую вершину из начала очереди
        vertex = queue.pop(0)

        # если вершина ещё не была посещена
        if vertex not in visited:
            # добавляем её в множество посещённых
            visited.add(vertex)

            # обрабатываем все соседние вершины для текущей
            for neighbor in graph[vertex]:
                # если сосед ещё не был посещён
                if neighbor not in visited:
                    # добавляем соседа в очередь для дальнейшей обработки
                    queue.append(neighbor)

                    # если расстояние до соседа ещё не задано (равно 0), обновляем его
                    # расстояние до соседа = расстояние до текущей вершины + 1
                    if distance[neighbor] == 0:
                        distance[neighbor] = distance[vertex] + 1


# ввод количества вершин и рёбер
n = int(input("Введите количество вершин: "))
m = int(input("Введите количество рёбер: "))

# инициализация графа как списка смежности (список списков)
graph = [[] for _ in range(n + 1)]  # индексы от 1 до n, индекс 0 не используется

# ввод рёбер графа
print("Введите рёбра графа (каждое ребро задаётся двумя вершинами):")
for _ in range(m):
    first = int(input(f"ребро №{_ + 1} : Введите вершину откуда: "))
    second = int(input(f"ребро №{_ + 1} : Введите вершину куда: "))
    # добавляем обе вершины в список смежности друг друга (неориентированный граф)
    graph[first].append(second)
    graph[second].append(first)


# инициализация массива расстояний (от начальной вершины до всех остальных)
# индекс 0 не используется, потому что вершины начинаются с 1
distance = [0 for _ in range(n + 1)]  # все вершины изначально на расстоянии 0, кроме стартовой

# ввод начальной вершины для BFS
start = int(input("Введите стартовую вершину: "))

# запуск алгоритма BFS
bfs(start, graph, distance)

# вывод расстояний от начальной вершины до каждой другой
print("\nРасстояния от начальной вершины:")
for i in range(1, len(distance)):
    print(f"От начальной вершины {start} до вершины {i}: расстояние = {distance[i]}")

# вывод максимального расстояния, которое является максимальным количеством шагов
print(f"\nМаксимальное количество шагов от {start} (начальной вершины) = {max(distance)}")
